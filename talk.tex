\documentclass{beamer}
\usepackage[utf8]{inputenc}

\usepackage{minted}
\usepackage{pgf}
\usepackage{tikz}
\usepackage{upquote}
\usepackage{hyperref}
\usetikzlibrary{arrows,automata}

\setbeamertemplate{footline}[frame number]
\setbeamertemplate{navigation symbols}{}

\title{A Dependently-Typed Zipper over GADT-Embedded ASTs}
\author{Donovan Crichton}
\date{November 2018}

\begin{document}
 
\frame{\titlepage}

\begin{frame}[fragile]
  \frametitle{Preliminaries}
  \begin{itemize}
    \item \textbf{Slides and examples available at:}
    \url{https://github.com/donovancrichton/talkdepzip.git}
  \item \textbf{About me:}
    \begin{itemize}
      \item Honours 'year' student at Griffith University.
      \item Working towards a type-correct genetic program through
              dependently-typed functional programming.
      \item About 18 months experience in FP, just under 12 with
              dependent types.
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{A refresher on dependent types 1.}
\begin{itemize}
  \item The most basic definition is a dependent data type (GADT in
          Haskell).
  \item Dependent data-types depend on being parameterised over a
        value for their construction.
  \item Distinguished from parameterised ADTs by the ability to
        specify the return type parameter of each data constructor.
\end{itemize}
\begin{minipage}{0.5\textwidth}
\begin{block}{A vector dependent on a length value.}
\begin{minted}[fontsize=\small,baselinestretch=1]{haskell}
  data Nat = Z | S Nat

  data Vec : (n : Nat) -> (e : Type) -> Type where
    Nil : Vec Z e
    (::) : (x : e) -> (xs : Vec n e) -> Vec (S Z) e
\end{minted}
\end{block}
\end{minipage}
\end{frame}

\begin{frame}[fragile]
  \frametitle{A refresher on dependent types 2.}

  \begin{block}{Why is this `good'?}
   If our length forms part of our type, we gain the ability
          to write correct functions with respect to vector length,
          without having to explicitly check. 
  \end{block}
  \begin{block}{Adding some vectors.}
  \begin{minted}[fontsize=\small]{haskell}
    -- total
    (+) : Num a => Vec n a -> Vec n a -> Vec n a
    (+) [] [] = []
    (+) (x :: xs) (y :: ys) = x + y :: xs + ys
  \end{minted}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{A refresher on dependent types 3.}
  \begin{block}{$\Pi$ types.}
    \begin{itemize}
     \item The $\Pi$ type is a family of types that are indexed by a
           value (hence type families in Haskell).
     \item $\Pi$ types are used to calculate correct return types
             when given a specified value.
     \item In Idris $\Pi$ types only fully refine if the functions
             requiring them are marked as total.
     \item In Idris functions that return $\Pi$ types don't always refine in 
             function composition, recursive calls or let bindings.
     \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{A refresher on dependent types 4.}
  \begin{block}{An example of using $\Pi$ types in Idris.}
  \begin{minted}[fontsize=\small]{haskell}
  Age : Type
  Age = Nat

  Name : Type
  Name = String

  data Material = Plastic | Wood | Metal | Cheese
  data Person = P Name Age
  data Object = O Material

  IsPerson : Bool -> Type
  IsPerson True = Person
  IsPerson False = Object

  isPerson : (x : Bool) -> IsPerson x
  isPerson True = P "Donovan Crichton" 33
  isPerson False = O Cheese
  \end{minted}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{A refresher on dependent types 5.}
  \begin{block}{$\Sigma$ types.}
  \begin{itemize}
    \item $\Sigma$ types are a pairing of a value, and a type that
            depends on that value (They are also called dependent
                  pairs).
    \item $\Sigma$ types are useful when you want some basic type
            inference around dependent types!
    \item In Idris it is difficult to extract either side of a $\Sigma$
          type pair. Particularly when that pair is under a
          constructor.
    \item Due to the dependent nature of the
            \mintinline{haskell}{fst} and \mintinline{haskell}{snd}
            functions on dependent pairs, they cannot be used with
            ordinary maps, folds, binds etc.
  \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{A refresher on dependent types 6.}
  \begin{block}{An example using $\Sigma$ types in Idris.}
  \begin{minted}[fontsize=\small]{haskell}
  data DPair : (a : Type) -> (P : a -> Type) -> Type where
    MkDPair : (x : a) -> (pf : P x) -> DPair a P

  -- also has some syntactic sugar in Idris.
  f : (x : Bool ** IsPerson x)
  f = (_ ** isPerson True)

  g : Num a => (n : Nat ** Vec n a)
  g = (_ ** [1, 2, 3])

  -- this is particularly useful if we are passing a vector
  -- of unknown length in as an argument.
  len : Num a => Vec n a -> (x : Nat ** Vec x a)
  len x = (_ ** x)

  -- len [1, 2, 3] returns
  -- (3 ** [1, 2, 3]) : (x : Nat ** Vec x Integer)
  \end{minted}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{A refresher on dependent types 7.}
  \begin{block}{Why are $\Sigma$ and $\Pi$ `good'?}
  \begin{itemize}
    \item It turns out that the curry-Howard isomorphsim
      still holds with the introduction of dependent types.
    \item Lets say we have some proof $P$ $x$, using a
      dependent-data-type or a $\Pi$ type is saying $\forall x, P$ $x$.
      Using a $\Sigma$ type is saying $\exists x, P$ $x$.
    \item This brings the isomorphic logic from propositional logic
      to first-order or predicate logic, allowing us to write proofs
      in our code (more on this later).
  \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Dependent data-type embedded DSLs 1.}
  \begin{block}{A quick review of DSLs}
    \begin{itemize}
      \item Short for Domain Specific Language.
      \item Used in lots of places, salary calculations, query and
        markup languages, business logic, etc.
      \item Used very much in programming language research!
    \end{itemize}
  \end{block}
  \begin{block}{A DDT (or GADT) embedded DSL}
    \begin{minted}[fontsize=\small]{haskell}
      data Expr : (a : Type) -> Type where
        Lit   : a -> Expr a
        Add   : Num a => Expr a -> Expr a -> Expr a
        Const : Expr a -> Expr b -> Expr a
    \end{minted}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Dependent data-type embedded DSLs 2.}
  \begin{block}{An embedded DSL and it's interpreter.}
    \begin{minted}[fontsize=\small]{haskell}
      data Expr : (a : Type) -> Type where
        Lit   : a -> Expr a
        Add   : Num a => Expr a -> Expr a -> Expr a
        Const : Expr a -> Expr b -> Expr a

      interp : Expr a -> a
      interp (Lit x)     = x
      interp (Add x y)   = (interp x) + (interp y)
      interp (Const x y) = const (interp x) (interp y)
    \end{minted}
  \end{block}
  \begin{block}{Why is an embedded DSL `good'?}
    \begin{itemize}
      \item It was very easy to write that interpreter.
      \item The type checker over the meta language takes care of
        type checking the DSL.
      \item The meta language also takes care of variable binding.
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]
\frametitle{Zipping over embedded DSLs LYAH style 1.}
    \begin{minted}[fontsize=\small]{haskell}
      data Expr : Type -> Type where
        Lit   : a -> Expr a
        Add   : Num a => Expr a -> Expr a -> Expr a
        Const : Expr a -> Expr b -> Expr a

      data Context = Root
        | L (Expr a) Context
        | R (Expr a) Context

      left : (Expr a, Context) -> (Expr a, Context)
      left (Lit x, c)     = (Lit x, c)
      left (Add x y, c)   = (x, L (Add x y) c)
      left (Const x y, c) = (x, L (Const x y) c)

      -- the problem comes when trying to write right
      right : (Expr a, Context) -> (Expr a, Context)
      right (Lit x, c)     = (Lit x, c)
      right (Add x y, c)   = (y, R (Add x y) c)
      right (Const x y, c) = (y, R (Const x y) c)
    \end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Zipper over embedded DSLs LYAH style 2.}
  \begin{block}{Why doesn't this work?}
    \begin{itemize}
      \item `left' works fine because the compiler can see
        that all instances of left result in an `Expr a'.
      \item `right' cannot type-check because the compiler
        sees that it returns an `Expr b' in the `Const' case.
    \end{itemize}
  \end{block}
  \begin{block}{Where to from here?}
    \begin{itemize}
      \item There is nothing stopping us from writing a nonsensical
        context and pairing it up with some expression. We'd like to
        avoid this.
      \item There are methods for traversing these well-typed ASTs
        via higher-order morphisms, they must touch every element of
        the tree however.
      \item Lets see where we can get using some dependent types!
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{A dependently typed zipper 1.}
  \begin{block}{Let's start with $\Pi$ types.}
    \begin{itemize}
    \item These $\Pi$ types will allow us to calculate the correct type
          of the context, and keep us honest when developing the zipper.
    \item Have a look at the `Maybe Type`. It doesn't make sense for us to
          build a type from going left or right on the `Lit x' case.
    \end{itemize}
    \begin{minted}[fontsize=\small]{haskell}
      GoLeft : Expr a -> Maybe Type
      GoLeft (Lit x) = Nothing
      GoLeft (Add {a} x y) = Just a
      GoLeft (Const {a} x y) = Just a

      GoRight : Expr a -> Maybe Type
      GoRight (Lit x) = Nothing
      GoRight (Add {a} x y) = Just a
      GoRight (Const {b} x y) = Just b
    \end{minted}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{A dependently typed zipper 2.}
  \begin{block}{Let's re-define the context.}
    \begin{itemize}
      \item By parameterising the context over our $\Pi$ types, we
        ensure that the type checker will fail when we try to build
        invalid contexts.
      \item Moving from an ADT to a DDT (GADT) gives us a lot more
        expressivity here! This is also a strong example of the
        dependence relationship in the type parameter.
    \end{itemize}
    \begin{minted}[fontsize=\small]{haskell}
data Context : Maybe Type -> Type where
  Root : Context (Just a)
  L : (x : Expr a) -> Context (Just a) -> Context (GoLeft x)
  R : (x : Expr a) -> Context (Just a) -> Context (GoRight x)
    \end{minted}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{A dependently typed zipper 3.}
  \begin{block}{Let's re-define the zipper.}
    \begin{itemize}
      \item We'd like to parameterise the zipper so that we can
        perform operations on zippers that have holes (or focii) of
        the same type.
      \item `wrap' is provided to give us an easy way of creating a
        $\Sigma$ type from a zipper, we wrap all this up in a `Maybe'
        as some zipping operations may fail.
    \end{itemize}
  \begin{minted}[fontsize=\small]{haskell}
data Zipper : Type -> Type where
  Zip : Expr a -> Context (Just a) -> Zipper a

wrap : Zipper a -> Maybe (a : Type ** Zipper a)
wrap x = Just (_ ** x)
  \end{minted}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{A dependently typed zipper 4.}
  \begin{block}{Re-defining the direction functions.}
    \begin{minted}[fontsize=\small]{haskell}
left : Maybe (a : Type ** Zipper a) 
    -> Maybe (b : Type ** Zipper b)
left Nothing = Nothing
left (Just (x ** pf)) = 
  case pf of
    (Zip p@(Lit x) c) => Nothing
    (Zip p@(Add x y) c) => Just (_ ** Zip x (L p c)) 
    (Zip p@(Const x y) c) => Just (_ ** Zip x (L p c)) 

right : Maybe (a : Type ** Zipper a) 
     -> Maybe (b : Type ** Zipper b)
right Nothing = Nothing
right (Just (x ** pf)) = 
  case pf of
    (Zip p@(Lit x) c) => Nothing 
    (Zip p@(Add x y) c) => Just (_ ** Zip y (R p c)) 
    (Zip p@(Const x y) c) => Just (_ ** Zip y (R p c)) 
     \end{minted}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{A dependently typed zipper 5.}
  \begin{block}{Notes on the left and right directions.}
    \begin{itemize}
      \item Thanks to the `GoLeft' and `GoRight' $\Pi$ types 
        we defined earlier. It's not possible to accidentally
        produce a focus of the incorrect type when implementing
        `left' and `right'.
      \item This idea of being unable to produce an incorrect value
        for a type is where the notions of proofs come from in
        dependently typed functional languages. We can say that
        the type is now correct by construction.
      \item Does the context need to store the full parent 
        expression? How much do we gain by returning a partially
        applied constructor? There is more to think about here!
      \item We need the different constructor tags for the next
        direction case.
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{A dependently typed zipper 6.}
  \begin{block}{More direction functions.}
    \begin{minted}[fontsize=\small]{haskell}
up : Maybe (a : Type ** Zipper a) 
  -> Maybe (b : Type ** Zipper b)
up Nothing = Nothing
up (Just (x ** pf)) =
 case pf of
  (Zip e Root) => Just (_ ** Zip e Root)
  (Zip e (R (Lit x) pc)) impossible
  (Zip e (R (Add x y) pc)) => Just (_ ** Zip (Add x e) pc)
  (Zip e (R (Const x y) pc)) => Just (_ ** Zip (Const x e) pc)
  (Zip e (L (Lit x) pc)) impossible
  (Zip e (L (Add x y) pc)) => Just (_ ** Zip (Add e y) pc)
  (Zip e (L (Const x y) pc)) => Just (_ ** Zip (Const e y) pc)
    \end{minted}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{A dependently typed zipper 7.}
  \begin{block}{\mintinline{haskell}{up} and $\Sigma$ types.}
    \begin{itemize}
      \item Remember, we say a function is total when it is defined
        for all cases and is guaranteed to terminate in finite time.
      \item $\Pi$ and $\Sigma$ types do not refine if used to define
        non-total functions in Idris.
      \item To make `up' total, we must list all the cases, however
        being able to construct a right and left case of `Lit x' is
        clearly nonsense! To convince the totality checker we can
        mark the case as impossible.
     \item $\Sigma$ types are ideal for when we do not know the 
       exact type of a function, but we know some properties that
       the inputs and outputs must adhere to.
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{A dependently typed zipper 8.}
  \begin{block}{Substitution and evaluation.}
  \begin{minted}[fontsize=\small]{haskell}
subst : (x : (a : Type ** Zipper a)) 
       -> Expr (fst x) 
       -> Maybe (a : Type ** Zipper a)
subst (x ** (Zip x' c)) e = Just (_ ** Zip e c)

data NotNothing : Maybe a -> Type where
  IsNotNothing : NotNothing (Just x)

fromMaybe : (input : Maybe (a : Type ** Zipper a))
           -> {auto prf : NotNothing input}
           -> (a : Type ** Zipper a)
fromMaybe (Just z) = z

interp : (x : (a : Type ** Zipper a)) -> (fst x)
interp (x ** (Zip e c)) = eval e
  \end{minted}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{A dependently typed zipper 9.}
  \begin{block}{Notes on substitution, interpretation and `Just' proofs.}
    \begin{itemize}
      \item We write `subst' under the assumption that we have an ordinary
        $\Sigma$ type parameterised by `a' and a further expression also
        parameterised by `fst x'. This ensures that the function will calculate
        the correct type!
      \item We defined `NotNothing' and `fromMaybe' to give us some tools
        to access the underlying type parameter. We can also achieve this
        with more $\Sigma$ types.
      \item Once we've removed the maybe we can lean on `fst' again to
        calculate the correct type for our evaluation.
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{But...does it actually work?}
  \begin{minted}[fontsize=\small]{haskell}
ex1 : Num a => Zipper a
ex1 = Zip (Const (Lit 2) (Lit "Test")) Root
-- Zip (Const (Lit 2) (Lit "Test")) Root

ex2 : Maybe (a : Type ** Zipper a)
ex2 = wrap ex1
-- Just (Integer ** Zip (Const (Lit 2) (Lit "Test")) Root)

ex3 : Maybe (a : Type ** Zipper a)
ex3 = right ex2
-- Just (String ** 
--   Zip (Lit "Test") (R (Const (Lit 2) (Lit "Test")) Root))

ex4 : Maybe (a : Type ** Zipper a)
ex4 = up (subst (fromMaybe ex3) (Lit "Hello"))
-- Just (Integer ** Zip (Const (Lit 2) (Lit "Hello")) Root)

ex5 : (DPair.fst (fromMaybe Main.ex4))
ex5 = interp (fromMaybe ex4)
-- 2
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Gotchas! (Further work).}
  \begin{itemize}
    \item If we're wrapping out $\Sigma$ types with `Maybe' then
      trying to say something like ``There may possibly exist a type,
      such that we can build a zipper out of it.'' which reads
      \mintinline{haskell}{Maybe (a : Type ** Zipper a)}
    \item It'd probably make more sense to say ``There definitely exists a
      type, that we may possibly build a zipper out of it.'' which would
        instead read \mintinline{haskell}{(a : Type ** Maybe (Zipper a))}.
        This means we could probably avoid the `NotNothing' proof and the
        `fromMaybe' function.
    \item How necessary is it to parameterise the context over a `Maybe Type'?
      We can probably achieve the same results without this!
    \item This is in no way generic! Our zipping functions, and our context
      are both tightly coupled to the structure of our DSL. Is there a way we
      can do better?
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{In summary.}
  \begin{itemize}
    \item We've shown the implementation of a method to correctly traverse a
      DDT-embedded DSL, where the types can be calculated at run-time.
    \item The goal here is to automate this process so that we can perform
      substitution and other transformations over well-typed expressions
      automatically.
    \item While there is still work to be done, hopefully this shows how
      dependent types can allow for both more rigour when developing software
      and more expressiveness when defining the types of our functions.
  \end{itemize}
\end{frame}

\end{document}
