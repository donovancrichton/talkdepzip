\documentclass{beamer}
\usepackage[utf8]{inputenc}

\usepackage{minted}
\usepackage{pgf}
\usepackage{tikz}
\usepackage{upquote}
\usepackage{hyperref}
\usetikzlibrary{arrows,automata}

\setbeamertemplate{footline}[frame number]
\setbeamertemplate{navigation symbols}{}

\title{A Dependently-Typed Zipper over GADT-Embedded ASTs}
\author{Donovan Crichton}
\date{November 2018}

\begin{document}
 
\frame{\titlepage}

\begin{frame}[fragile]
  \frametitle{Preliminaries}
  \begin{itemize}
    \item \textbf{Slides and examples available at:}
    \url{https://github.com/donovancrichton/talkdepzip.git}
  \item \textbf{About me:}
    \begin{itemize}
      \item Honours 'year' student at Griffith University.
      \item Working towards a type-correct genetic program through
              dependently-typed functional programming.
      \item About 18 months experience in FP, just under 12 with
              dependent types.
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{A refresher on dependent types 1.}
\begin{itemize}
  \item The most basic definition is a dependent data type (GADT in
          Haskell).
  \item Dependent data-types depend on being parameterised over a
        value for their construction.
  \item Distinguished from parameterised ADTs by the ability to
        specify the return type parameter of each data constructor.
\end{itemize}
\begin{minipage}{0.5\textwidth}
\begin{block}{A vector dependent on a length value.}
\begin{minted}[fontsize=\small,baselinestretch=1]{haskell}
  data Nat = Z | S Nat

  data Vec : (n : Nat) -> (e : Type) -> Type where
    Nil : Vec Z e
    (::) : (x : e) -> (xs : Vec n e) -> Vec (S Z) e
\end{minted}
\end{block}
\end{minipage}
\end{frame}

\begin{frame}[fragile]
  \frametitle{A refresher on dependent types 2.}

  \begin{block}{Why is this `good'?}
   If our length forms part of our type, we gain the ability
          to write correct functions with respect to vector length,
          without having to explicitly check. 
  \end{block}
  \begin{block}{Adding some vectors.}
  \begin{minted}[fontsize=\small]{haskell}
    -- total
    (+) : Num a => Vect n a -> Vect n a -> Vect n a
    (+) [] [] = []
    (+) (x :: xs) (y :: ys) = x + y :: xs + ys
  \end{minted}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{A refresher on dependent types 3.}
  \begin{block}{$\Pi$ types.}
    \begin{itemize}
     \item The $\Pi$ type is a family of types that are indexed by a
           value (hence type families in Haskell).
     \item $\Pi$ types are used to calculate correct return types
             when given a specified value.
     \item In Idris $\Pi$ types only fully refine if the functions
             requiring them are marked as total.
     \item In Idris functions that return $\Pi$ types don't always refine in 
             function composition, recursive calls or let bindings.
     \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{A refresher on dependent types 4.}
  \begin{block}{An example of using $\Pi$ types in Idris.}
  \begin{minted}[fontsize=\small]{haskell}
  Age : Type
  Age = Nat

  Name : Type
  Name = String

  data Material = Plastic | Wood | Metal | Cheese
  data Person = P Name Age
  data Object = O Material

  IsPerson : Bool -> Type
  IsPerson True = Person
  IsPerson False = Object

  isPerson : (x : Bool) -> IsPerson x
  isPerson True = P "Donovan Crichton" 33
  isPerson False = O Cheese
  \end{minted}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{A refresher on dependent types 5.}
  \begin{block}{$\Sigma$ types.}
  \begin{itemize}
    \item $\Sigma$ types are a pairing of a value, and a type that
            depends on that value (They are also called dependent
                  pairs).
    \item $\Sigma$ types are useful when you want some basic type
            inference around dependent types!
    \item In Idris it is difficult to extract either side of a $\Sigma$
          type pair. Particularly when that pair is under a
          constructor.
    \item Due to the dependent nature of the
            \mintinline{haskell}{fst} and \mintinline{haskell}{snd}
            functions on dependent pairs, they cannot be used with
            ordinary maps, folds, binds etc.
  \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{A refresher on dependent types 6.}
  \begin{block}{An example using $\Sigma$ types in Idris.}
  \begin{minted}[fontsize=\small]{haskell}
  data DPair : (a : Type) -> (P : a -> Type) -> Type where
    MkDPair : (x : a) -> (pf : P x) -> DPair a P

  -- also has some syntactic sugar in Idris.
  f : (x : Bool ** IsPerson x)
  f = (_ ** isPerson True)

  g : Num a => (n : Nat ** Vec n a)
  g = (_ ** [1, 2, 3])

  -- this is particularly useful if we are passing a vector
  -- of unknown length in as an argument.
  len : Num a => Vec n a -> (x : Nat ** Vec x a)
  len x = (_ ** x)

  -- len [1, 2, 3] returns
  -- (3 ** [1, 2, 3]) : (x : Nat ** Vec x Integer)
  \end{minted}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{A refresher on dependent types 7.}
  \begin{block}{Why are $\Sigma$ and $\Pi$ `good'?}
  \begin{itemize}
    \item It turns out that the curry-howard isomorphsim
      still holds with the introduction of dependent types.
    \item Lets say we have some proof $P$ $x$, using a
      dependent-data-type or a $\Pi$ type is saying $\forall x, P$ $x$.
      Using a $\Sigma$ type is saying $\exists x, P$ $x$.
    \item This brings the isomorphic logic from propositional logic
      to first-order or predicate logic, allowing us to write proofs
      in our code (more on this later).
  \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Dependent data-type embedded DSLs 1.}
  \begin{block}{A quick review of DSLs}
    \begin{itemize}
      \item Short for Domain Specific Language.
      \item Used in lots of places, salary calculations, query and
        markup languages, business logic, etc.
      \item Used very much in programming language research!
    \end{itemize}
  \end{block}
  \begin{block}{A DDT (or GADT) embedded DSL}
    \begin{minted}[fontsize=\small]{haskell}
      data Expr : (a : Type) -> Type where
        Lit   : a -> Expr a
        Add   : Num a => Expr a -> Expr a -> Expr a
        Const : Expr a -> Expr b -> Expr a
    \end{minted}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Dependent data-type embedded DSLs 2.}
  \begin{block}{An embedded DSL and it's interpreter.}
    \begin{minted}[fontsize=\small]{haskell}
      data Expr : (a : Type) -> Type where
        Lit   : a -> Expr a
        Add   : Num a => Expr a -> Expr a -> Expr a
        Const : Expr a -> Expr b -> Expr a

      interp : Expr a -> a
      interp (Lit x)     = x
      interp (Add x y)   = (interp x) + (interp y)
      interp (Const x y) = const (interp x) (interp y)
    \end{minted}
  \end{block}
  \begin{block}{Why is an embedded DSL `good'?}
    \begin{itemize}
      \item It was very easy to write that interpreter.
      \item The type checker over the meta language takes care of
        type checking the DSL.
      \item The meta language also takes care of variable binding.
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]
\frametitle{Zipping over embedded DSLs LYAH style 1.}
    \begin{minted}[fontsize=\small]{haskell}
      data Expr : Type -> Type where
        Lit   : a -> Expr a
        Add   : Num a => Expr a -> Expr a -> Expr a
        Const : Expr a -> Expr b -> Expr a

      data Context = Root
        | L (Expr a) Context
        | R (Expr a) Context

      left : (Expr a, Context) -> (Expr a, Context)
      left (Lit x, c)     = (Lit x, c)
      left (Add x y, c)   = (x, L (Add x y) c)
      left (Const x y, c) = (x, L (Const x y) c)

      -- the problem comes when trying to write right
      right : (Expr a, Context) -> (Expr a, Context)
      right (Lit x, c)     = (Lit x, c)
      right (Add x y, c)   = (y, R (Add x y) c)
      right (Const x y, c) = (y, R (Const x y) c)
    \end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Zipper over embedded DSLs LYAH style 2.}
  \begin{block}{Why doesn't this work?}
    \begin{itemize}
      \item `left' works fine because the compiler can see
        that all instances of left result in an `Expr a'.
      \item `right' cannot typecheck because the compiler
        sees that it returns an `Expr b' in the `Const' case.
    \end{itemize}
  \end{block}
  \begin{block}{Where to from here?}
    \begin{itemize}
      \item There is nothing stopping us from writing a non-sensical
        context and pairing it up with some expression. We'd like to
        avoid this.
      \item There are methods for traversing these well-typed ASTs
        via higher-order morphisms, they must touch every element of
        the tree however.
      \item Lets see where we can get using some dependent types!
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{A dependently typed zipper 1.}
  \begin{block}{Let's start with $\Pi$ types.}
    \begin{itemize}
    \item These $\Pi$ types will allow us to calculate the correct type
          of the context, and keep us honest when developing the zipper.
    \item Have a look at the `Maybe Type`. It doesn't make sense for us to
          build a type from going left or right on the `Lit x' case.
    \end{itemize}
    \begin{minted}[fontsize=\small]{haskell}
      GoLeft : Expr a -> Maybe Type
      GoLeft (Lit x) = Nothing
      GoLeft (Add {a} x y) = Just a
      GoLeft (Const {a} x y) = Just a

      GoRight : Expr a -> Maybe Type
      GoRight (Lit x) = Nothing
      GoRight (Add {a} x y) = Just a
      GoRight (Const {b} x y) = Just b
    \end{minted}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{A dependently typed zipper 2.}
  \begin{block}{Let's re-define the context.}
    \begin{itemize}
      \item By parameterising the context over our $\Pi$ types, we
        ensure that the type checker will fail when we try to build
        invalid contexts.
      \item Moving from an ADT to a DDT (GADT) gives us a lot more
        expressivity here! This is also a strong example of the
        dependence relationship in the type parameter.
    \end{itemize}
    \begin{minted}[fontsize=\small]{haskell}
data Context : Maybe Type -> Type where
  Root : Context (Just a)
  L : (x : Expr a) -> Context (Just a) -> Context (GoLeft x)
  R : (x : Expr a) -> Context (Just a) -> Context (GoRight x)
    \end{minted}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{A dependently typed zipper 3.}
  \begin{block}{Let's re-define the zipper.}
    \begin{itemize}
      \item We'd like to parameterise the zipper so that we can
        perform operations on zippers that have holes (or focii) of
        the same type.
      \item `wrap' is provided to give us an easy way of creating a
        $\Sigma$ type from a zipper, we wrap all this up in a `Maybe'
        as some zipping operations may fail.
    \end{itemize}
  \begin{minted}[fontsize=\small]{haskell}
data Zipper : Type -> Type where
  Zip : Expr a -> Context (Just a) -> Zipper a

wrap : Zipper a -> Maybe (a : Type ** Zipper a)
wrap x = Just (_ ** x)
  \end{minted}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{A dependently typed zipper 4.}
  \begin{block}{Re-defining the direction functions.}
    \begin{minted}[fontsize=\small]{haskell}
left : Maybe (a : Type ** Zipper a) 
    -> Maybe (b : Type ** Zipper b)
left Nothing = Nothing
left (Just (x ** pf)) = 
  case pf of
    (Zip p@(Lit x) c) => Nothing
    (Zip p@(Add x y) c) => Just (_ ** Zip x (L p c)) 
    (Zip p@(Const x y) c) => Just (_ ** Zip x (L p c)) 

right : Maybe (a : Type ** Zipper a) 
     -> Maybe (b : Type ** Zipper b)
right Nothing = Nothing
right (Just (x ** pf)) = 
  case pf of
    (Zip p@(Lit x) c) => Nothing 
    (Zip p@(Add x y) c) => Just (_ ** Zip y (R p c)) 
    (Zip p@(Const x y) c) => Just (_ ** Zip y (R p c)) 
     \end{minted}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{A dependently typed zipper 5.}
  \begin{block}{More direction functions.}
    \begin{minted}[fontsize=\small]{haskell}
up : Maybe (a : Type ** Zipper a) 
  -> Maybe (b : Type ** Zipper b)
up Nothing = Nothing
up (Just (x ** pf)) =
 case pf of
  (Zip e Root) => Just (_ ** Zip e Root)
  (Zip e (R (Lit x) pc)) impossible
  (Zip e (R (Add x y) pc)) => Just (_ ** Zip (Add x e) pc)
  (Zip e (R (Const x y) pc)) => Just (_ ** Zip (Const x e) pc)
  (Zip e (L (Lit x) pc)) impossible
  (Zip e (L (Add x y) pc)) => Just (_ ** Zip (Add e y) pc)
  (Zip e (L (Const x y) pc)) => Just (_ ** Zip (Const e y) pc)
    \end{minted}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{A dependently typed zipper 6.}
  \begin{block}{A note on the use of $\Sigma$ types.}
    \begin{itemize}
      \item The 
    \end{itemize}
  \end{block}
\end{frame}

\end{document}
